[[_contributing_project]]
=== An einem Projekt mitarbeiten

(((contributing)))
Die größte Schwierigkeit bei der Beschreibung der Mitarbeit an einem Projekt besteht darin, dass es eine große Anzahl von Variationen gibt, wie dies geschehen kann.
Da Git sehr flexibel ist, bietet es den Menschen viele Möglichkeiten der Zusammenarbeit, und es ist problematisch zu beschreiben, wie Sie mitarbeiten sollten, da jedes Projekt ein bisschen anders ist.
Einige der variablen Größen dabei sind die Anzahl der aktiven Mitarbeiter, der gewählte Arbeitsablauf, Ihre Zugriffsrechte und möglicherweise eine externe Methode der Mitarbeit.

Die erste variable Größe ist die Anzahl der aktiven Mitarbeiter - wie viele Nutzer steuern aktiv Code zu diesem Projekt bei und wie häufig?
In vielen Fällen gibt es zwei oder drei Entwickler mit ein paar Commits pro Tag, oder auch weniger bei irgendwie ruhenden Projekten.
Bei größeren Firmen oder Projekten kann die Anzahl der Entwickler in die Tausende reichen mit hunderten oder tausenden eingehenden Commits pro Tag.
Das ist deshalb von Bedeutung, da Sie mit einer wachsenden Anzahl von Entwicklern auch sicherstellen müssen, dass sich der Code problemlos anwenden lässt und leicht zusammengeführt werden kann.
Änderungen, die Sie übermitteln, können sich als überflüssig oder dysfunktional erweisen durch Beiträge, die inzwischen eingefügt wurden, während Sie noch an ihren Änderungen arbeiteten oder darauf warteten, dass diese geprüft oder angewendet werden.
Wie können Sie Ihren Code permanent auf dem neusten Stand halten und dafür sorgen, dass Ihre Commits gültig sind?

Die nächste Variable ist der für das Projekt verwendete Arbeitsablauf.
Ist es ein zentralisierter Arbeitsablauf, in dem jeder Entwickler die gleichen Schreibrechte auf die Hauptentwicklungslinie hat?
Gibt es bei dem Projekt einen Projektbetreiber oder Integrationsmanager, der alle Patches prüft?
Werden die Patches durch eine bestimmte Gruppe oder öffentlich, z. B. durch die Community, geprüft?
Sind Sie selbst an diesem Prozess beteiligt?
Gibt es ein Leutnant-System und müssen Sie Ihre Arbeit zunächst an einen solchen übermitteln?

Eine weiteres Thema sind ihre Commit-Zugriffsrechte.
Der erforderliche Arbeitsablauf, um Änderungen zu einem Projekt beizusteuern, ist ein ganz anderer, wenn Sie über Schreibrechte verfügen, als wenn das nicht der Fall ist.
Und wenn Sie keine Schreibrechte haben, in welcher Form müssen Sie ihre Änderungen bei diesem Projekt vorzugsweise übermitteln?
Gibt es dafür überhaupt eine Richtlinie?
Wie umfangreich sind die Änderungen, die Sie jeweils beisteuern?
Und wie häufig tun Sie das?

All diese Aspekte haben Einfluss darauf, wie Sie effektiv an einem Projekt mitarbeiten können und welche Arbeitsabläufe bevorzugt werden oder verfügbar für Sie sind.
Wir werden verschiedene Aspekte davon in einer Reihe von Fallbeispielen betrachten, wobei wir mit simplen Beispielen anfangen und später komplexere Szenarios besprechen. Sie sollten in der Lage sein, anhand dieser Beispiele die spezifischen Arbeitsabläufe zu erstellen, die Sie in der Praxis benötigen.

[[_commit_guidelines]]
==== Richtlinien für Commits

Bevor wir damit beginnen, spezifische Anwendungsfälle zu betrachten, hier noch eine kurze Anmerkung zu Commit-Nachrichten.
Ein gute Richtlinie für das Erzeugen von Commits zu haben und sich daran zu halten, macht die Arbeit mit Git und die Zusammenarbeit mit anderen um vieles leichter.
Das Git-Projekt stellt ein Dokument bereit, welches eine Reihe von guten Tipps für das Erzeugen von Commits zum Übermitteln von Patches beinhaltet. Sie können die Tipps in der Datei `Documentation/SubmittingPatches` im Git-Quellcode nachlesen.

(((git commands, diff, check)))
Als Erstes wollen Sie keinerlei Leerzeichenfehler übermitteln.
Git bietet eine einfache Möglichkeit, dies zu überprüfen - bevor Sie einen Commit vornehmen, führen Sie die Anweisung `git diff --check` aus, welche mögliche Leerzeichenfehler erkennt und für Sie auflistet.

.Ausgabe von `git diff --check`.
image::images/git-diff-check.png[Ausgabe von `git diff --check`.]

Wenn Sie diese Anweisung vor einem Commit ausführen, können Sie erkennen, ob Sie dabei sind, Leerzeichenfehler zu übermitteln, welche andere Entwickler verärgern könnten.

Als Nächstes, versuchen Sie, aus jedem Commit einen logisch getrennten Satz von Änderungen zu machen.
Wenn Sie können, versuchen Sie, Ihre Änderungen leicht verdaulich zu machen - arbeiten Sie nicht ein ganzes Wochenende an fünf verschiedenen Themen und übermitteln Sie dann all diese Änderungen in einem massiven Commit am Montag.
Auch wenn Sie am Wochenende keine Commits durchführen, nutzen Sie am Montag die Staging Area, um Ihre Änderungen aufzuteilen in wenigstens einen Commit für jeden Teilaspekt mit jeweils einer sinnvollen Nachricht.
Wenn einige der Änderungen die selbe Datei modifizieren, benutzen Sie die Anweisung `git add --patch`, um Dateien partiell zur Staging Area hinzuzufügen (detailiert dargestellt im Abschnitt <<ch07-git-tools#_interactive_staging>>).
Der Schnappschuss vom Projekt an der Spitze des Branches ist der Selbe, ob Sie einen oder fünf Commits durchgeführt haben, solange nur all die Änderungen irgendwann hinzugefügt werden. Versuchen Sie also, die Dinge zu vereinfachen für Ihre Entwicklerkollegen, die Ihre Änderungen begutachten müssen.

Dieser Ansatz macht es außerdem einfacher, einen Satz von Änderungen zu entfernen oder rückgängig zu machen, falls das später nötig wäre.
<<ch07-git-tools#_rewriting_history>> beschreibt eine Reihe nützlicher Git-Tricks zum Umschreiben des Verlaufs oder um interaktiv Dateien zur Staging Area hinzuzufügen. Verwenden Sie diese Werkzeuge, um einen sauberen und leicht verständlichen Verlauf aufzubauen, bevor Sie Ihre Arbeit jemand anderem schicken.

Ein weitere Sache, die Sie nicht vergessen sollten, ist die Commit-Nachricht.
Wenn man sich angewöhnt, aussagekräftige und hochwertige Commit-Nachrichten zu schreiben, ist die Benutzung von Git viel einfacher und es erleichtert die Zusammenarbeit.
In der Regel sollte Ihre Commit-Nachricht mit einer einzelnen Zeile anfangen, die nicht länger als 50 Zeichen sein sollte und die Änderungen kurz und bündig beschreibt, gefolgt von einer leeren Zeile, welcher eine ausführlichere Beschreibung der Änderungen folgt.
Das Git-Projekt fordert, dass die detailliertere Erklärung Ihre Motivation für die Änderungen beinhaltet und deren Implementierung dem vorhergehenden Verhalten gegenüberstellt. Das ist eine gute Richtlinie, an die man sich halten sollte.
Es empfiehlt sich außerdem, die Gegenwartsform des Imperativ in diesen Nachrichten zu benutzen. Mit anderen Worten, verwenden Sie Anweisungen. Anstatt „Ich habe Test hinzugefügt für“ oder „Tests hinzufügend für“ benutzen Sie „Füge Tests hinzu für“.
Hier ist ein https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html[Muster, welches ursprünglich von Tim Pope stammt]:

[source,text]
----
Kurze (50 Zeichen oder weniger) Zusammenfassung der Änderungen

Detailliert erklärender Text, wenn nötig. Beschränken Sie diesen auf
ca. 72 Zeichen. In Abhängigkeit vom Kontext wird die erste Zeile
manchmal wie die Betreff-Zeile einer E-Mail behandelt und der übrige
Text wie der Textkörper der Nachricht. Die leere Zeile, welche die
Zusammenfassung vom Text trennt, ist kritisch (außer Sie lassen den Text
komplett weg); Werkzeuge wie Rebase können durcheinander kommen, wenn
Sie beide gleichzeitig verwenden.

Weitere Absätze folgen jeweils nach leeren Zeilen.

. Aufzählungspunkte kann man auch verwenden

* Typischer Weise nutzt man Bindestriche oder Sternchen
  als Aufzählungszeichen, denen ein einzelnes Leerzeichen
  vorangestellt wird, die einzelnen Punkte werden durch
  leere Zeilen getrennt, die Konventionen variieren hier

      einen hängenden Einzug benutzen
----

Wenn alle Ihre Commit-Nachrichten so aussehen, werden die Dinge für Sie und die Entwickler, mit denen Sie zusammenarbeiten, viel einfacher sein.
Das Git-Projekt selbst hat wohl-formatierte Commit-Nachrichten – führen Sie mal die Anweisung `git log --no-merges` aus, um zu sehen, wie ein angenehm formatierter Commit-Verlauf eines Projektes aussieht.

In den folgenden Beispielen und fast überall in diesem Buch finden Sie der Kürze halber keine angenehm formatierten Meldungen wie diese. Stattdessen wird die Anweisung `git commit` zusammen mit der Option `-m` verwendet.
Also folgen Sie meinen Worten und nicht meinem Beispiel.


[NOTE]
.Mach es wie wir sagen, nicht wie wir es tun.
====
Der Kürze halber haben viele der Beispiele in diesem Buch keine gut formatierten Commit-Nachrichten wie diese. Stattdessen verwenden wir einfach die Option `-m`, um `-m` auszuführen.

Kurz, mach es wie wir sagen, nicht wie wir es tun.
====

[[_private_team]]
==== Privates kleines Team

(((contributing, private small team)))
Das einfachste Szenario, dem Sie sehr wahrscheinlich begegnen werden, ist ein vertrauliches Projekt mit einem oder zwei Entwicklern.
„Private“ in diesem Zusammenhang bedeutet „closed source“ - nicht öffentlich zugänglich für die Außenwelt.
Sie und die anderen Entwickler haben alle Schreibzugriff auf das Repository.

Sie können sich in diesem Umfeld an einen Arbeitsablauf halten, den Sie genauso auch bei Subversion oder einem anderen zentralisierten System verwenden könnten.
Sie genießen dann immer noch die Vorteile von Dingen, wie Commits offline durchführen zu können und erheblich einfacher Branches anzulegen und zusammenzuführen, der Arbeitsablauf kann sehr ähnlich sein. Der Hauptunterschied ist, dass das Zusammenführen eher auf der Client-Seite stattfindet als auf dem Server beim Durchführen eines Commits.
Lassen Sie uns betrachten, wie es aussehen könnte, wenn zwei Entwickler damit beginnen, an einem gemeinsamen Repository zu arbeiten.
Der erste Entwickler, John, klont das Repository, nimmt eine Änderung vor und führt lokal einen Commit durch.
(Die Protokoll-Nachrichten wurden in diesen Beispielen durch `...` ersetzt, um das Ganze etwas zu kürzen.)

[source,console]
----
# John's Machine
$ git clone john@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'remove invalid default value'
[master 738ee87] remove invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)
----

Die zweite Entwicklerin, Jessica, tut dasselbe. Sie klont das Repository, ändert etwas und führt einen Commit durch.

[source,console]
----
# Jessica's Machine
$ git clone jessica@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)
----

Nun lädt Jessica ihre Arbeit auf den Server hoch:

[source,console]
----
# Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -> master
----

Die letzte Zeile der obigen Ausgabe zeigt eine nützliche Rückmeldung aus  aus der Push-Operation.
Das Ausgangsformat ist `<oldref>..<newref> fromref -> toref`, wobei `oldref` die alte Referenz bedeutet, `newref` die neue Referenz bedeutet, `fromref` der Name der zu verschiebenden lokalen Referenz ist und `toref` der Name der zu aktualisierenden Fernreferenz ist.
Sie werden ähnliche Ausgaben wie diese unten in den Diskussionsrunden sehen, so dass eine grundlegende Vorstellung der Bedeutung hilft, die verschiedenen Zustände der Repositorien zu verstehen.
Weitere Details finden Sie in der Dokumentation zu https://git-scm.com/docs/git-push[git-push].

In Fortsetzung dieses Beispiels nimmt John kurz darauf einige Änderungen vor, überträgt sie in sein lokales Repository und versucht, sie auf den gleichen Server zu verschieben:

[source,console]
----
# John's Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -> master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
----

John ist es nicht gestattet, seine Änderungen hochzuladen, weil Jessica vorher _ihre_ hochgeladen hat.
Dies zu verstehen, ist besonders wichtig, wenn Sie dem Umgang mit Subversion gewöhnt sind, weil Sie bemerkt haben werden, dass die beiden Entwickler nicht die gleiche Datei bearbeitet haben.
Obwohl Subversion automatisch das Zusammenführen auf dem Server durchführt, wenn zwei verschiedene Dateien bearbeitet werden, müssen Sie die Commits bei Git _zuerst_ lokal zusammenführen.
Anders ausgedrückt: John muss erst Jessicas Änderungen abholen und lokal mit seinen zusammenführen, bevor ihm das Hochladen gestattet wird.

Als ersten Schritt ruft John Jessicas Arbeit ab (dies ruft nur Jessicas Vorgängerarbeit ab, er verbindet sie noch nicht mit Johns Arbeit):

[source,console]
----
$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -> origin/master
----

Zu diesem Zeitpunkt sieht Johns lokales Repository ungefähr so aus:

.Johns abzweigender Verlauf.
image::images/small-team-1.png[John's divergent history.]

Jetzt kann John Jessicas Arbeit, die er abgerufen hat, mit seiner eigenen lokalen Arbeit zusammenführen:

[source,console]
----
$ git merge origin/master
Merge made by the 'recursive' strategy.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
----

Das Zusammenführen läuft problemlos - Johns Commit-Verlauf sieht jetzt so aus:

.Johns Repository nach dem Zusammenführen mit `origin/master`.
image::images/small-team-2.png[John's repository after merging `origin/master`.]

Jetzt kann John seinen Code überprüfen, um sicherzustellen, dass dieser immer noch ordnungsgemäß funktioniert, und dann kann er seine neue, zusammengeführte Arbeit auf den Server hochladen:

[source,console]
----
$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -> master
----

Schließlich sieht Johns Commit-Verlauf so aus:

.Johns Verlauf nach dem Hochladen auf den `origin`-Server.
image::images/small-team-3.png[John's history after pushing to the `origin` server.]

Jesicca hat in der Zwischenzeit an einem neuen Branch gearbeitet. Sie hat einen Branch namens `issue54` erzeugt und auf diesem Branch drei Commits durchgeführt.
Noch hat sie Johns Änderungen nicht vom Server abgeholt, sodass ihr Commit-Verlauf jetzt so aussieht:

.Jessicas Branches.
image::images/small-team-4.png[Jessica's topic branch.]

Plötzlich erfährt Jessica, dass John neue Arbeit auf den Server geschoben hat und sie will sich das ansehen. Deshalb muss sie alle neuen Inhalte vom Server abrufen über die sie noch nicht verfügt:

[source,console]
----
# Jessica's Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -> origin/master
----

Das lädt alle Änderungen herunter, die John in der Zwischenzeit hochgeladen hat.
Jessicas Verlauf sieht nun so aus:

.Jessicas Verlauf nach dem Abholen von Johns Änderungen.
image::images/small-team-5.png[Jessica's history after fetching John's changes.]

Jessica denkt, dass ihr Branch fertig ist, aber sie möchte wissen, welchen Teil von Johns abgerufenen Arbeiten sie in ihre Arbeit einbinden muss, damit sie ihrerseits hochladen kann.
Sie führt die Anweisung `git log` aus, um es herauszufinden:

[source,console]
----
$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 16:01:27 2009 -0700

   remove invalid default value
----

Bei der Syntax `issue54..origin/master` handelt es sich um einen log-Filter, der Git anweist, nur die Commits aufzulisten, welche auf dem letzteren Branch durchgeführt wurden (in diesem Fall `origin/master`) und die sich nicht auf dem ersten Branch befinden (in diesem Fall `issue54`).
Wir werden diese Syntax detailliert in <<ch07-git-tools#_commit_ranges>> erläutern.

Fürs Erste können wir an der Ausgabe erkennen, dass es einen einzelnen Commit von John gibt, den Jessica noch nicht bei sich eingefügt hat.
Dieser einzelne Commit modifiziert ihre lokalen Änderungen, wenn sie ihren Branch mit `origin/master` zusammenführt.

Jetzt kann Jessica ihren "issue54"-Branch mit ihrem `master`-Branch zusammenführen, danach Johns Arbeit (`origin/master`) mit ihrem `master`-Branch zusammenführen und dann das Ganze auf den Server hochladen.

Zuerst wechselt sie zu ihrem `master`-Branch, um alle diese Änderungen zu integrieren:

[source,console]
----
$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
----

Sie kann entweder `origin/master` oder `issue54` zuerst integrieren, da sie beide "stromaufwärts" angeordnet sind, spielt die Reihefolge keine Rolle.
Der Snapshot am Ende sollte identisch sein, egal, welche Reihenfolge sie wählt, nur der Verlauf wird ein wenig anders sein.
Sie entscheidet sich dafür, `issue54` zuerst einfließen zu lassen.

[source,console]
----
$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)
----

Es treten keine Probleme auf; wie Sie sehen können, war es ein einfacher "Fast-Forward".
Jessica vervollständigt nun den lokalen Merge-Prozess, indem sie Johns früher geholte Arbeit zusammenführt, die im Branch `origin/master` liegt:

[source,console]
----
$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by the 'recursive' strategy.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
----

Alles lässt sich sauber zusammenführen und Jessicas Verlauf sieht jetzt so aus:

.Jessicas Verlauf nach dem Zusammenführen mit Johns Änderungen.
image::images/small-team-6.png[Jessica's history after merging John's changes.]

Jetzt ist `origin/master` von Jessicas `master`-Branch aus erreichbar, sodass sie in der Lage sein sollte, erfolgreich hochladen zu können (vorausgesetzt, John hat nicht inzwischen schon wieder etwas hochgeladen):

[source,console]
----
$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -> master
----

Jeder Entwickler hat einige Commits durchgeführt und jeweils die Arbeiten des anderen mit den eigenen zusammengeführt.

.Jessicas Verlauf nach dem Hochladen aller Änderungen auf den Server.
image::images/small-team-7.png[Jessica's history after pushing all changes back to the server.]

Das ist einer der einfachsten Arbeitsabläufe.
Sie arbeiten eine Weile, gewöhnlich an einem Themenbranch, und führen diesen mit ihrem master-Branch zusammen, wenn dieser soweit fertig ist, dass er integriert werden kann.
Wenn Sie diese Arbeit mit anderen teilen wollen, führen Sie die Änderungen mit ihrem eigenen `master`-Branch zusammen, holen eventuelle Änderungen vom Branch `origin/master` ab und führen diese mit ihren `master`-Branch zusammen, und schließlich laden sie alles auf den `master`-Branch auf den Server hoch.
Der generelle Ablauf sieht ungefähr so aus:

.Genereller Ablauf von Ereignissen für einen einfachen Arbeitsablauf mit mehreren Entwicklern.
image::images/small-team-flow.png[General sequence of events for a simple multiple-developer Git workflow.]

==== Geführte private Teams

(((contributing, private managed team)))
In diesem Szenario werden Sie die Funktionen von Mitarbeitern in einem größeren, nicht öffentlich arbeitenden Team betrachten.
Sie werden erfahren, wie Sie in einem Umfeld arbeiten können, wo in kleinen Gruppen an der Entwicklung einzelner Features gearbeitet wird und dann diese team-basierten Beiträge durch einen anderen Beteiligten integriert werden.

Sagen wir, John und Jessica arbeiten gerade zusammen an einem Feature, während Jessica und Josie gerade an einem zweiten arbeiten.
Das Unternehmen benutzt in diesem Fall einen Typ des Arbeitsablaufs mit Integrationsmanager, bei dem die Arbeit der individuellen Gruppen nur durch bestimmte Mitarbeiter integriert wird und der `master`-Branch des Haupt-Repositorys auch nur durch eben diese Mitarbeiter aktualisiert werden kann.
Die ganze Arbeit wird in diesem Szenario auf team-basierten Branches ausgeführt und später von den Integrationsmanagern zusammengeführt.

Lassen Sie uns Jessicas Arbeitsablauf betrachten, wie sie in diesem Umfeld parallel mit zwei verschiedenen Entwicklern an ihren beiden Features arbeitet.
Vorausgesetzt, sie hat ihr Repository bereits geklont, entscheidet sie sich, zuerst an `featureA` zu arbeiten.
Sie erzeugt einen neuen Branch für das Feature und arbeitet etwas daran:

[source,console]
----
# Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)
----

An diesem Punkt muss sie den Stand ihrer Arbeiten John mitteilen, also lädt sie ihre Commits von `featureA`-Branch auf den Server hoch.
Jessica hat keine Schreibrechte auf dem `master`-Branch - den haben nur die Integrationsmanager - also muss sie auf einen anderen Branch hochladen, um mit John zusammenarbeiten zu können.

[source,console]
----
$ git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -> featureA
----

Jessica sendet John eine E-Mail, um ihm mitzuteilen, dass einige Änderungen auf einen neuen Branch namens `featureA` hochgeladen hat und er nun einen Blick darauf werfen kann.
Während sie auf ein Feedback von John wartet, entscheidet sich Jessica, mit der Arbeit an `featureB` zu beginnen - diesmal gemeinsam mit Josie.
Am Anfang legt sie einen neuen Feature-Branch an, basierend auf dem `master`-Branch, welcher sich auf dem Server befindet (`origin/master`):

[source,console]
----
# Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'
----

Jetzt führt Jessica eine Reihe von Commits auf dem `featureB`-Branch durch:

[source,console]
----
$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)
----

Jessicas Repository sieht jetzt so aus:

.Jessicas ursprünglicher Commit-Verlauf.
image::images/managed-team-1.png[Jessica's initial commit history.]

Jessica könnte ihre Arbeit jetzt hochladen, aber sie bekommt eine E-Mail von Josie, in der diese mitteilt, dass bereits ein Branch namens `featureBee` hochgeladen wurde, welcher einige erste Änderungen beinhaltet.
Jessica muss also erst diese Änderungen mit ihren eigenen Änderungen zusammenführen, bevor sie selbst etwas hochladen kann.
Sie kann Josies Änderungen mit `git fetch` herunterladen:

[source,console]
----
$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -> origin/featureBee
----

Angenommen, Jessica befindet sich noch in ihrem ausgecheckten `featureB` Branch und kann nun Josies Arbeit mit `git merge` in diesen Zweig einbinden:

[source,console]
----
$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by the 'recursive' strategy.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)
----

Jetzt möchte Jessica alle zusammengeführten featureB-Arbeiten zurück auf den Server schieben, aber sie will nicht sie einfach ihren eigenen featureB-Zweig hochschieben.
Da Josie bereits einen Upstream-FeatureBee-Zweig gestartet hat, will Jessica zu diesem Branch hochladen, indem sie folgenden Befehl ausführt:

[source,console]
----
$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -> featureBee
----

Das bezeichnet man als _refspec_.
Siehe <<ch10-git-internals#_refspec>> für eine ausführlichere Beschreibung der Git „refspecs“ und den unterschiedlichen Möglichkeiten, die Sie damit haben.
Beachten Sie auch das `-u` Flag, eine Abkürzung für `--set-upstream`, das die Branches für später leichtere Pushs und Pulls konfiguriert.

Als Nächstes sendet John eine E-Mail an Jessica, um sie zu informieren, dass er einige Änderungen auf den `featureA`-Branch hochgeladen hat, und sie bittet, diese zu überprüfen.
Wieder Sie führt die Anweisung `git fetch` aus, um diese Änderungen herunter zu laden:

[source,console]
----
$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -> origin/featureA
----

Jessica kann sich das Protokoll von Johns neuer Arbeit anzeigen lassen indem sie den Inhalt des neu abgerufenen Branch `featureA` mit ihrer lokalen Kopie des gleichen Zweiges vergleicht:

[source,console]
----
$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25
----

Wenn ihr Johns neue Arbeit gefällt, kann sie sie mit ihrem lokalen Branch `featureA` verschmelzen:

[source,console]
----
$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)
----

Schließlich möchte Jessica möglicherweise ein paar geringfügige Änderungen an dem gesamten zusammengeführten Inhalt vornehmen. Sie kann diese Änderungen vornehmen, sie in ihren lokalen Zweig 'featureA' übertragen und das Endergebnis zurück auf den Server übertragen:

[source,console]
----
$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -> featureA
----

Jessicas Commit-Verlauf sieht jetzt ungefähr so aus:

.Jessicas Verlauf nach dem Commit auf den Feature-Branch.
image::images/managed-team-2.png[Jessica's history after committing on a feature branch.]

Irgendwann informieren Jessica, Josie und John die Integratoren, dass die Zweige `featureA` und `featureBee` auf dem Server für die Integration in die Hauptlinie bereit sind.
Nachdem die Integratoren diese Branches in der Hauptlinie zusammengeführt haben, wird beim Abrufen das neue Merge-Commit beendet, sodass der Verlauf wie folgt aussieht:

.Jessicas Verlauf nach dem Zusammenführen mit ihren beiden Themenbranches.
image::images/managed-team-3.png[Jessica's history after merging both her topic branches.]

Viele Teams wechseln zu Git, weil es damit möglich ist, dass mehrere Teams parallel arbeiten können und die verschiedenen Entwicklungslinien erst später im Prozess zusammengeführt werden.
Ein riesiger Vorteil von Git besteht darin, dass man in kleinen Untergruppen eines Teams über entfernte Branches zusammenarbeiten kann, ohne notwendigerweise das gesamte Team zu involvieren oder zu behindern.
Die Reihenfolge bei dem Arbeitsablauf, den Sie gesehen haben, ist ungefähr folgende:

.Grundlegende Reihenfolge des Arbeitsablaufs bei einem geführten Team.
image::images/managed-team-flow.png[Basic sequence of this managed-team workflow.]

[[_public_project]]
==== Verteiltes öffentliches Projekt

(((contributing, public small project)))
An einem öffentlichen Projekt mitzuarbeiten, ist ein wenig anders.
Da Sie keine Berechtigungen haben, die Branches des Projektes direkt zu aktualisieren, müssen Sie die Änderungen auf andere Art und Weise zu den Projektbetreibern bekommen.
Dieses erste Beispiel beschreibt die Mitarbeit mittels "Forking" auf Git-Hosting-Servern, welche einfaches "Forking" unterstützen.
Viele Hosting-Websites unterstützen dies (einschließlich GitHub, BitBucket, Google Code repo.or.cz und andere), und viele Projektbetreiber erwarten diese Art der Mitarbeit.
Der nächste Abschnitt handelt von Projekten, welche die Abgabe von Patches via E-Mail  bevorzugt akzeptieren.

Zunächst werden Sie vermutlich das Hauptrepository klonen wollen, einen Themenbranch anlegen für den Patch oder die Serie von Patches, die Sie beisteuern möchten, und dann darin arbeiten.
Die Reihenfolge sieht dann in etwa so aus:

[source,console]
----
$ git clone <url>
$ cd project
$ git checkout -b featureA
  ... work ...
$ git commit
  ... work ...
$ git commit
----

[NOTE]
====
Sie können `rebase -i` verwenden, um Ihre Arbeit auf einen einzelnen Commit zu reduzieren oder die Arbeit in den Commits neu anzuordnen damit der Patch für den Maintainer einfacher zu überprüfen ist – siehe <<ch07-git-tools#_rewriting_history>> für weitere Informationen über interaktives Rebasing.
====

Wenn Sie mit der Arbeit an ihrem Branch fertig sind und Sie ihren Beitrag den Projektbetreibern zur Verfügung stellen wollen, gehen Sie auf die Projektseite und klicken auf den „Fork“ Button, um Ihren eigenen Fork des Projektes anzulegen, in den Sie dann schreiben können.
Anschließend müssen Sie diese Repository-URL als neue Remote-Adresse Ihres lokalen Repositorys hinzufügen. Nennen wir es in diesem Beispiel `myfork`:

[source,console]
----
$ git remote add myfork <url>
----

Dann müssen Sie Ihre Änderungen dorthin hochladen.
Es ist am einfachsten, den Themenbranch, an dem Sie arbeiten, in Ihr Forked-Repository hochzuladen, anstatt diese Arbeit in Ihrem Master-Zweig zusammenzuführen und dorthin zu verschieben.
Der Grund dafür ist, dass Sie Ihren `master` Branch nicht zurücksetzen müssen, wenn Ihre Arbeit nicht angenommen oder ausgewählt wurde (die Git-Operation `cherry-pick` zum Auswählen einzelner Commits wird in <<ch05-distributed-git#_rebase_cherry_pick>> ausführlicher behandelt).
Wenn die Projektbetreiber Ihre Änderungen übernehmen, ob mit `merge`, `rebase` oder `cherry-pick`, werden Sie diese schließlich sowieso zurückbekommen mittels `git pull` von deren Repository.

Auf jeden Fall können Sie Ihre Arbeit voranbringen mit:

[source,console]
----
$ git push -u myfork featureA
----

(((git commands, request-pull)))
Sobald Ihre Arbeit auf Ihren Fork des Repository verschoben wurde, müssen Sie die Maintainer des ursprünglichen Projekts darüber informieren, dass Sie Arbeit haben, die Sie zusammenführen möchten.
Das wird oft als _pull request_ bezeichnet, und Sie generieren eine solche Anforderung typischerweise entweder über die Website – GitHub hat einen eigenen „Pull-Request“ Mechanismus, den wir im <<ch06-github#ch06-github> durchgehen werden – oder Sie können den Befehl `git request-pull` ausführen und die nachfolgende Ausgabe manuell per E-Mail an den Projektbetreuer senden.

Die Anweisung `git request-pull` verwendet den Ausgangsbranch, für den Ihre Änderungen bestimmt sind, und die URL des Git-Repositorys, von dem Ihre Änderungen heruntergeladen werden sollen, und gibt eine Zusammenfassung aller Änderungen aus, um deren Übernahme Sie bitten.
Wenn Jessica z.B. einen pull request an John schicken will, und sie zwei Commits auf dem gerade hochgeladenen Themenbranch durchgeführt hat, kann sie diese Anweisung ausführen:

[source,console]
----
$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
Jessica Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)
----

Diese Meldung kann an den Betreuer gesendet werden – sie teilt ihm mit, woher die Arbeit stammt, fasst die Commits zusammen und gibt an, von wo die neue Arbeit geholt werden soll.

Bei einem Projekt, für das Sie nicht der Betreuer sind, ist es im Allgemeinen einfacher, einen Branch wie `master` zu haben, welcher immer dem `origin/master` Branch folgt, und Ihre eigenen Änderungen in Themenbranches vorzunehmen, die Sie leicht verwerfen können, wenn diese nicht akzeptiert werden.
Wenn Sie Schwerpunkte Ihrer Arbeit in Themenbranches unterteilen, können Sie diese außerdem recht leicht auf den letzten Stand des Hauptrepositorys rebasen, falls das Hauptrepository in der Zwischenzeit weiter entwickelt wurde und Ihre Commits sich nicht mehr sauber anwenden lassen.
Wollen Sie beispielsweise Änderungen zu einem weiteren Thema dem Projekt beisteuern, dann arbeiten Sie nicht weiter auf dem Themenbranch, den Sie gerade hochgeladen haben - sondern beginnen Sie von vorn vom `master` Branch des Hauptrepositorys:

[source,console]
----
$ git checkout -b featureB origin/master
  ... work ...
$ git commit
$ git push myfork featureB
$ git request-pull origin/master myfork
  ... email generated request pull to maintainer ...
$ git fetch origin
----

Jedes Ihrer Themen befindet sich jetzt in einer Art Silo – ähnlich einer Patch Queue – sodass Sie diese neu schreiben, rebasen und ändern können, ohne dass die Branches sich gegemseitig stören oder voneinander abhängen:

.Ursprünglicher Commit-Verlauf bei der Arbeit an `featureB`.
image::images/public-small-1.png[Initial commit history with `featureB` work.]

Nehmen wir an, der Projektbetreiber hat eine Menge von anderen Patches übernommen und versucht, Ihren ersten Branch einfließen zu lassen, aber dieser lässt sich nicht mehr sauber anwenden.
In diesem Fall können Sie Ihre Änderungen auf dem letzten Stand des `origin/master` Branch mittels Rebase hinzufügen, die Konflikte für den Projektbetreiber beheben und Ihre Arbeit erneut einreichen:

[source,console]
----
$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA
----

Das schreibt Ihren Commit-Verlauf neu, sodass dieser jetzt so aussieht <<psp_b>>.

[[psp_b]]
.Commit-Verlauf nach dem Rebase von `featureA`.
image::images/public-small-2.png[Commit history after `featureA` work.]

Da Sie den Branch mittels Rebase hinzugefügt haben, müssen Sie die Anweisung `git push` mit der Option `-f` verwenden, um den `featureA`-Branch auf dem Server mit einem Commit ersetzen zu können, der nicht vom gegenwärtig letzten Commit des entfernten Branches abstammt.
Eine Alternative dazu wäre, diese neuen Änderungen in einen anderen Branch auf dem Server hochzuladen (vielleicht namens `featureAv2`).

Schauen wir uns noch ein weiteres mögliches Szenario an: der Projektbetreiber hat sich Ihre Arbeit in Ihrem zweiten Branch angesehen und mag das Konzept, aber er bittet Sie, noch ein Detail an der Implementierung zu ändern.
Sie werden die Gelegenheit außerdem nutzen, um Ihre Änderungen zu verschieben, damit diese auf dem aktuellen `master` Branch des Projektes basieren.
Sie legen dazu ausgehend vom aktuellen `origin/master` Branch einen neuen Branch an, führen Ihre Änderungen aus `featureB` damit zusammen, lösen dabei jegliche Konflikte, erledigen die gewünschte Änderung an der Implementierung und laden das Ganze als neuen Branch hoch:

(((git commands, merge, squash)))
[source,console]
----
$ git checkout -b featureBv2 origin/master
$ git merge --squash featureB
  ... change implementation ...
$ git commit
$ git push myfork featureBv2
----

Die Option `--squash` fasst alle Änderungen des einfließenden Branches (featureB) zusammen und komprimiert sie in ein Change-Set, das den Zustand des Repositorys erzeugt, als ob ein echter Merge stattgefunden hätte, ohne tatsächlich einen Merge Commit zu machen.
Das bedeutet, dass Ihr zukünftiger Commit nur einen Elternteil hat und Ihnen ermöglicht, sämtliche Änderungen aus einem anderen Branch zu übernehmen und dann weitere Änderungen vorzunehmen, bevor Sie einen neuen Commit aufzeichnen.
Die Option `--no-commit` weist Git außerdem an, nicht automatisch einen Commit anzulegen.

Jetzt können Sie dem Projektbetreiber eine Nachricht schicken, dass Sie die gewünschten Änderungen vorgenommen haben und dass er Ihre Änderungen in Ihrem `featureBv2`-Branch finden kann.

.Commit-Verlauf nach den Änderungen an `featureBv2`.
image::images/public-small-3.png[Commit history after `featureBv2` work.]

[[_project_over_email]]
==== Öffentliches Projekt via E-Mail

(((contributing, public large project)))
Viele Projekte haben festgelegte Verfahren, um Patches entgegenzunehmen – Sie werden sich mit den jeweiligen Regeln vertraut machen müssen, da diese bei jedem Projekt unterschiedlich sein werden.
Da es etliche ältere, große Projekte gibt, welche Patches über eine Mailingliste der Entwickler entgegennehmen, werden wir auf dieses Beispiel als Nächstes eingehen.

Der Arbeitsablauf ist ähnlich dem im vorherigen Anwendungsfall – Sie erzeugen Themenbranches für jede Patchserie, an der Sie arbeiten.
Der Unterschied besteht dann darin, wie Sie die Änderungen an das Projekt übermitteln.
Anstatt das Projekt zu forken und Änderungen in Ihren Fork hochzuladen, erzeugen Sie E-Mail-Versionen von jeder Ihrer Commit-Folgen und senden diese an die Mailingliste der Entwickler.

[source,console]
----
$ git checkout -b topicA
  ... work ...
$ git commit
  ... work ...
$ git commit
----

(((git commands, format-patch)))
Jetzt haben Sie zwei Commits, die Sie an die Mailingliste schicken wollen.
Sie verwenden die Anweisung `git format-patch`, um die Dateien im mbox-Format zu erzeugen, die Sie per E-Mail an die Mailingliste schicken können - diese Anweisung macht aus jedem Commit eine E-Mail-Nachricht, wobei die erste Zeile der Commit-Nachricht zum Betreff der E-Mail wird und der Rest der Commit-Nachricht sowie der Patch des Commits selbst wird zum Text der E-Mail.
Das Schöne daran ist, dass bei der Anwendung eines Patches von einer mit `format-patch` erzeugten E-Mail alle Commit-Informationen ordnungsgemäß erhalten bleiben.

[source,console]
----
$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
----

Die Anweisung `git format-patch` zeigt Ihnen die Namen der Patch-Dateien an, die er erzeugt hat.
Die Option `-M` weist Git an, nach umbenannten Dateien Ausschau zu halten.
Die Dateien sehen dann so aus:

[source,console]
----
$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0
----

Sie können diese Patch-Dateien auch bearbeiten, um weitere Informationen für die Mailingliste hinzuzufügen, die nicht in der Commit-Nachricht erscheinen sollen.
Wenn Sie Text zwischen der `---` Zeile und dem Anfang des Patches (der Zeile `diff --git`) hinzufügen, dann können die Entwickler diesen lesen, bei der Anwendung des Patches wird er aber ausgeschlossen.

Um das jetzt an eine Mailingliste zu schicken, können Sie die Datei entweder in Ihrem E-Mail Programm einfügen oder sie über ein Befehlszeilen-Programm direkt verschicken.
Das Einfügen des Textes verursacht oft Formatierungsprobleme – insbesondere mit „smarten“ E-Mail-Clients, welche Zeilenumbrüche und Leerzeichen nicht adäquat erhalten.
Glücklicherweise bietet Git ein Tool, das Ihnen hilft, ordnungsgemäß formatierte Patches über IMAP zu verschicken, was einfacher für Sie sein könnte.
Wir werden demonstrieren, wie man Patches über Gmail verschickt, welches der E-Mail-Client ist, mit dem wir uns am besten auskennen; Sie können detaillierte Anleitungen für eine Reihe von E-Mail-Programme am Ende der schon erwähnten Datei `Documentation/SubmittingPatches` im Git Quellcode nachlesen.

(((git commands, config)))(((email)))
Zunächst müssen Sie den Abschnitt IMAP in Ihrer `~/.gitconfig` Datei einrichten.
Sie können jeden Wert separat mit einer Reihe von `git config` Anweisungen eingeben oder die Datei öffnen und die Werte manuell eingeben, am Ende sollte Ihre config-Datei in etwa so aussehen:

[source,ini]
----
[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = YX]8g76G_2^sFbd
  port = 993
  sslverify = false
----

Wenn Ihr IMAP-Server kein SSL verwendet, sind die letzten beiden Zeilen wahrscheinlich nicht nötig und der Host-Wert müsste `imap://` statt `imaps://` lauten.
Wenn Sie diese Einstellungen vorgenommen haben, können Sie `git send-email` verwenden, um die Patches im Entwurfsordner des angegebenen IMAP-Servers zu platzieren:

[source,console]
----
$ cat *.patch |git imap-send
Resolving imap.gmail.com... ok
Connecting to [74.125.142.109]:993... ok
Logging in...
sending 2 messages
100% (2/2) done
----

At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you're sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.

You can also send the patches through an SMTP server.
As before, you can set each value separately with a series of `git config` commands, or you can add them manually in the sendemail section in your `~/.gitconfig` file:

[source,ini]
----
[sendemail]
  smtpencryption = tls
  smtpserver = smtp.gmail.com
  smtpuser = user@gmail.com
  smtpserverport = 587
----

After this is done, you can use `git send-email` to send your patches:

[source,console]
----
$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
Emails will be sent from: Jessica Smith <jessica@example.com>
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
----

Git gibt dann für jeden Patch, den Sie versenden, ein paar Log-Informationen aus, die in etwa so aussehen:

[source,text]
----
(mbox) Adding cc: Jessica Smith <jessica@example.com> from
  \line 'From: Jessica Smith <jessica@example.com>'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith <jessica@example.com>
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: <y>
References: <y>

Result: OK
----

==== Zusammenfassung

Dieser Abschnitt hat eine Reihe von gebräuchlichen Arbeitsabläufen behandelt, die für jeweils sehr verschiedene Arten von Projekten üblich sind und denen Du vermutlich begegnen wirst. Wir haben außerdem ein paar neue Tools vorgestellt, die dabei hilfreich sind, diese Workflows umzusetzen.
Als nächstes werden wir auf die andere Seite dieser Medaille eingehen: wie Sie selbst ein Git Projekt betreiben können.
Sie werden erfahren, wie Sie als „wohlwollender Diktator“ oder als Integrationsmanager arbeiten können.
