[[_contributing_project]]
=== An einem Projekt mitarbeiten

(((contributing)))
Die größte Schwierigkeit bei der Beschreibung der Mitarbeit an einem Projekt besteht darin, dass es eine große Anzahl von Variationen gibt, wie dies geschehen kann.
Da Git sehr flexibel ist, bietet es den Menschen viele Möglichkeiten der Zusammenarbeit, und es ist problematisch zu beschreiben, wie Sie mitarbeiten sollten, da jedes Projekt ein bisschen anders ist.
Einige der variablen Größen dabei sind die Anzahl der aktiven Mitarbeiter, der gewählte Arbeitsablauf, Ihre Zugriffsrechte und möglicherweise eine externe Methode der Mitarbeit.

Die erste variable Größe ist die Anzahl der aktiven Mitarbeiter - wie viele Nutzer steuern aktiv Code zu diesem Projekt bei und wie häufig?
In vielen Fällen gibt es zwei oder drei Entwickler mit ein paar Commits pro Tag, oder auch weniger bei irgendwie ruhenden Projekten.
Bei größeren Firmen oder Projekten kann die Anzahl der Entwickler in die Tausende reichen mit hunderten oder tausenden eingehenden Commits pro Tag.
Das ist deshalb von Bedeutung, da Sie mit einer wachsenden Anzahl von Entwicklern auch sicherstellen müssen, dass sich der Code problemlos anwenden lässt und leicht zusammengeführt werden kann.
Änderungen, die Sie übermitteln, können sich als überflüssig oder dysfunktional erweisen durch Beiträge, die inzwischen eingefügt wurden, während Sie noch an ihren Änderungen arbeiteten oder darauf warteten, dass diese geprüft oder angewendet werden.
Wie können Sie Ihren Code permanent auf dem neusten Stand halten und dafür sorgen, dass Ihre Commits gültig sind?

Die nächste Variable ist der für das Projekt verwendete Arbeitsablauf.
Ist es ein zentralisierter Arbeitsablauf, in dem jeder Entwickler die gleichen Schreibrechte auf die Hauptentwicklungslinie hat?
Gibt es bei dem Projekt einen Projektbetreiber oder Integrationsmanager, der alle Patches prüft?
Werden die Patches durch eine bestimmte Gruppe oder öffentlich, z. B. durch die Community, geprüft?
Sind Sie selbst an diesem Prozess beteiligt?
Gibt es ein Leutnant-System und müssen Sie Ihre Arbeit zunächst an einen solchen übermitteln?

Eine weiteres Thema sind ihre Commit-Zugriffsrechte.
Der erforderliche Arbeitsablauf, um Änderungen zu einem Projekt beizusteuern, ist ein ganz anderer, wenn Sie über Schreibrechte verfügen, als wenn das nicht der Fall ist.
Und wenn Sie keine Schreibrechte haben, in welcher Form müssen Sie ihre Änderungen bei diesem Projekt vorzugsweise übermitteln?
Gibt es dafür überhaupt eine Richtlinie?
Wie umfangreich sind die Änderungen, die Sie jeweils beisteuern?
Und wie häufig tun Sie das?

All diese Aspekte haben Einfluss darauf, wie Sie effektiv an einem Projekt mitarbeiten können und welche Arbeitsabläufe bevorzugt werden oder verfügbar für Sie sind.
Wir werden verschiedene Aspekte davon in einer Reihe von Fallbeispielen betrachten, wobei wir mit simplen Beispielen anfangen und später komplexere Szenarios besprechen. Sie sollten in der Lage sein, anhand dieser Beispiele die spezifischen Arbeitsabläufe zu erstellen, die Sie in der Praxis benötigen.

[[_commit_guidelines]]
==== Richtlinien für Commits

Bevor wir damit beginnen, spezifische Anwendungsfälle zu betrachten, hier noch eine kurze Anmerkung zu Commit-Nachrichten.
Ein gute Richtlinie für das Erzeugen von Commits zu haben und sich daran zu halten, macht die Arbeit mit Git und die Zusammenarbeit mit anderen um vieles leichter.
Das Git-Projekt stellt ein Dokument bereit, welches eine Reihe von guten Tipps für das Erzeugen von Commits zum Übermitteln von Patches beinhaltet. Sie können die Tipps in der Datei `Documentation/SubmittingPatches` im Git-Quellcode nachlesen.

(((git commands, diff, check)))
Als Erstes wollen Sie keinerlei Leerzeichenfehler übermitteln.
Git bietet eine einfache Möglichkeit, dies zu überprüfen - bevor Sie einen Commit vornehmen, führen Sie die Anweisung `git diff --check` aus, welche mögliche Leerzeichenfehler erkennt und für Sie auflistet. 

.Ausgabe von `git diff --check`.
image::images/git-diff-check.png[Ausgabe von `git diff --check`.]

Wenn Sie diese Anweisung vor einem Commit ausführen, können Sie erkennen, ob Sie dabei sind, Leerzeichenfehler zu übermitteln, welche andere Entwickler verärgern könnten.

Als Nächstes, versuchen Sie, aus jedem Commit einen logisch getrennten Satz von Änderungen zu machen.
Wenn Sie können, versuchen Sie, Ihre Änderungen leicht verdaulich zu machen - arbeiten Sie nicht ein ganzes Wochenende an fünf verschiedenen Themen und übermitteln Sie dann all diese Änderungen in einem massiven Commit am Montag.
Auch wenn Sie am Wochenende keine Commits durchführen, nutzen Sie am Montag die Staging Area, um Ihre Änderungen aufzuteilen in wenigstens einen Commit für jeden Teilaspekt mit jeweils einer sinnvollen Nachricht.
Wenn einige der Änderungen die selbe Datei modifizieren, benutzen Sie die Anweisung `git add --patch`, um Dateien partiell zur Staging Area hinzuzufügen (detailiert dargestellt im Abschnitt <<_interactive_staging>>).
Der Schnappschuss vom Projekt an der Spitze des Branches ist der Selbe, ob Sie einen oder fünf Commits durchgeführt haben, solange nur all die Änderungen irgendwann hinzugefügt werden. Versuchen Sie also, die Dinge zu vereinfachen für Ihre Entwicklerkollegen, die Ihre Änderungen begutachten müssen.
Dieser Ansatz macht es außerdem einfacher, einen Satz von Änderungen zu entfernen oder rückgängig zu machen, falls das später nötig wäre.
<<_rewriting_history>> beschreibt eine Reihe nützlicher Git-Tricks zum Umschreiben des Verlaufs oder um interaktiv Dateien zur Staging Area hinzuzufügen. Verwenden Sie diese Werkzeuge, um einen sauberen und leicht verständlichen Verlauf aufzubauen, bevor Sie Ihre Arbeit jemand anderem schicken.

Ein weitere Sache, die Sie nicht vergessen sollten, ist die Commit-Nachricht.
Wenn man sich angewöhnt, aussagekräftige und hochwertige Commit-Nachrichten zu schreiben, ist die Benutzung von Git viel einfacher und es erleichtert die Zusammenarbeit.
In der Regel sollte Ihre Commit-Nachricht mit einer einzelnen Zeile anfangen, die nicht länger als 50 Zeichen sein sollte und die Änderungen kurz und bündig beschreibt, gefolgt von einer leeren Zeile, welcher eine ausführlichere Beschreibung der Änderungen folgt.
Das Git-Projekt fordert, dass die detailliertere Erklärung Ihre Motivation für die Änderungen beinhaltet und deren Implementierung dem vorhergehenden Verhalten gegenüberstellt. Das ist eine gute Richtlinie, an die man sich halten sollte.
Es empfiehlt sich außerdem, die Gegenwartsform des Imperativ in diesen Nachrichten zu benutzen.
Mit anderen Worten, nutzen Sie Anweisungen.
Anstatt ``Ich habe Test hinzugefügt für'' oder ``Tests hinzufügend für'' benutzen Sie ``Füge Tests hinzu für''.
Hier ist ein Muster, welches ursprünglich von Tim Pope stammt:

[source,text]
-----
Kurze (50 Zeichen oder weniger) Zusammenfassung der Änderungen

Detailliert erklärender Text, wenn nötig. Beschränken Sie
diesen auf ca. 72 Zeichen. In Abhängigkeit vom Kontext wird
die erste Zeile manchmal wie die Betreff-Zeile einer E-Mail
behandelt und der übrige Text wie der Textkörper der
Nachricht. Die leere Zeile, welche die Zusammenfassung vom
Text trennt, ist kritisch (außer Sie lassen den Text komplett
weg); Werkzeuge wie Rebase können durcheinander kommen, wenn
Sie beide gleichzeitig verwenden.

Weitere Absätze folgen jeweils nach leeren Zeilen.

  - Aufzählungspunkte kann man auch verwenden

  - Typischer Weise nutzt man Bindestriche oder Sternchen
    als Aufzählungszeichen, denen ein einzelnes Leerzeichen
	vorangestellt wird, die einzelnen Punkte werden durch
    leere Zeilen getrennt, die Konventionen variieren hier
	
-----

Wenn alle Ihre Commit-Nachrichten so aussehen, werden die Dinge für Sie und die Entwickler, mit denen Sie zusammenarbeiten, viel einfacher sein.
Das Git-Projekt selbst hat wohl-formatierte Commit-Nachrichten - führen Sie mal die Anweisung `git log --no-merges` aus, um zu sehen, wie ein angenehm formatierter Commit-Verlauf eines Projektes aussieht.

In den folgenden Beispielen und fast überall in diesem Buch finden Sie der Kürze halber keine angenehm formatierten Meldungen wie diese. Stattdessen wird die Anweisung `git commit` zusammen mit der Option `-m` verwendet.
Also folgen Sie meinen Worten und nicht meinem Beispiel.


[[_private_team]]
==== Vertrauliches kleines Team

(((contributing, private small team)))
Das einfachste Szenario, dem Sie sehr wahrscheinlich begegnen werden, ist ein vertrauliches Projekt mit einem oder zwei Entwicklern.
``Private'' in diesem Zusammenhang bedeutet "closed source" - nicht öffentlich zugänglich für die Außenwelt.
Sie und die anderen Entwickler haben alle Schreibzugriff auf das Repository.

Sie können sich in diesem Umfeld an einen Arbeitsablauf halten, den Sie genauso auch bei Subversion oder einem anderen zentralisierten System verwenden könnten.
Sie genießen dann immer noch die Vorteile von Dingen, wie Commits offline durchführen zu können und erheblich einfacher Branches anzulegen und zusammenzuführen, aber der Arbeitsablauf kann sehr ähnlich sein. Der Hauptunterschied ist, dass das Zusammenführen eher auf der Client-Seite stattfindet als auf dem Server beim Durchführen eines Commits.
Lassen Sie uns betrachten, wie es aussehen könnte, wenn zwei Entwickler damit beginnen, an einem gemeinsamen Repository zu arbeiten.
Der erste Entwickler, John, klont das Repository, nimmt eine Änderung vor und führt lokal einen Commit durch.
(Die Protokoll-Nachrichten wurden in diesen Beispielen durch `...` ersetzt, um das Ganze etwas zu kürzen.)

[source,console]
-----
# John's Machine
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'removed invalid default value'
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

Die zweite Entwicklerin, Jessica, tut das Selbe. Sie klont das Repository, ändert etwas und führt einen Commit durch.

[source,console]
-----
# Jessica's Machine
$ git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)
-----

Nun lädt Jessica ihre Arbeit auf den Server hoch:

[source,console]
-----
# Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -> master
-----

John versucht ebenfalls, seine Änderungen hochzuladen:

[source,console]
-----
# John's Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -> master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
-----

John ist es nicht gestattet, seine Änderungen hochzuladen, weil Jessica inzwischen ihre hochgeladen hat.
Dies zu verstehen, ist besonders wichtig, wenn Sie dem Umgang mit Subversion gewöhnt sind, weil Sie bemerkt haben werden, dass die beiden Entwickler nicht die gleiche Datei bearbeitet haben.
Obwohl Subversion automatisch das Zusammenführen auf dem Server durchführt, wenn zwei verschiedene Dateien bearbeitet werden, müssen Sie die Commits bei Git lokal zusammenführen.
John muss erst Jessicas Änderungen abholen und lokal mit seinen zusammenführen, bevor ihm das Hochladen gestattet wird.

[source,console]
-----
$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -> origin/master
-----

Zu diesem Zeitpunkt sieht Johns lokales Repository ungefähr so aus:

.Johns abzweigender Verlauf.
image::images/small-team-1.png[John's divergent history.]

John hat einen Bezug zu den Änderungen, welche Jessica hochgeladen hat, aber er muss diese erst mit seiner eigenen Arbeit zusammenführen, bevor es ihm gestattet ist, selbst hochzuladen.

[source,console]
-----
$ git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
-----

Das Zusammenführen läuft problemlos - Johns Commit-Verlauf sieht jetzt so aus:

.Johns Repository nach dem Zusammenführen mit `origin/master`.
image::images/small-team-2.png[John's repository after merging `origin/master`.]

Jetzt kann John seinen Code überprüfen, um sicherzustellen, dass dieser immer noch ordnungsgemäß funktioniert, und dann kann er seine neue, zusammengeführte Arbeit auf den Server hochladen:

[source,console]
-----
$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -> master
-----

Schließlich sieht Johns Commit-Verlauf so aus:

.Johns Verlauf nach dem Hochladen auf den `origin`-Server.
image::images/small-team-3.png[John's history after pushing to the `origin` server.]

Jesicca hat in der Zwischenzeit an einem Themenbranch gearbeitet.
Sie hat einen Themenbranch namens `issue54` erzeugt und auf diesem Branch drei Commits durchgeführt.
Noch hat sie Johns Änderungen nicht vom Server abgeholt, sodass ihr Commit-Verlauf jetzt so aussieht:

.Jessicas Themenbranch.
image::images/small-team-4.png[Jessica's topic branch.]

Jessica möchte ihren Stand mit Johns synchronisieren, also führt sie die Anweisung `git fetch origin` aus:

[source,console]
-----
# Jessica's Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -> origin/master
-----

Das lädt alle Änderungen herunter, die John in der Zwischenzeit hochgeladen hat.
Jessicas Verlauf sieht nun so aus:

.Jessicas Verlauf nach dem Abholen von Johns Änderungen.
image::images/small-team-5.png[Jessica's history after fetching John's changes.]

Jessica denkt, dass ihr Themenbranch fertig ist, aber sie möchte wissen, welche Änderung sie mit ihrer Arbeit zusammenführen muss, damit sie ihrerseits hochladen kann.
Sie führt die Anweisung `git log` aus, um dies herauszufinden:

[source,console]
-----
$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 16:01:27 2009 -0700

   removed invalid default value
-----

Bei der Syntax `issue54..origin/master` handelt es sich um einen log-Filter, der Git anweist, nur die Commits aufzulisten, welche auf dem letzteren Branch durchgeführt wurden (in diesem Fall `origin/master`) und die sich nicht auf dem ersten Branch befinden (in diesem Fall `issue54`). Wir werden uns diese Syntax detailliert in <<_commit_ranges>>.

Fürs Erste können wir an der Ausgabe erkennen, dass es einen einzelnen Commit von John gibt, den Jessica noch nicht bei sich eingefügt hat. Dieser einzelne Commit modifiziert ihre lokalen Änderungen, wenn sie ihren Branch mit `origin/master` zusammenführt. 

Jetzt kann Jessica ihren Themenbranch mit ihrem `master`-Branch zusammenführen, danach Johns Arbeit (`origin/master`) mit ihrem `master`-Branch zusammenführen und dann das Ganze auf den Server hochladen.
Zuerst wechselt sie zu ihrem `master`-Branch, um alle diese Änderungen zu integrieren:

[source,console]
-----
$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
-----

Sie kann entweder `origin/master` oder `issue54` zuerst integrieren, da sie beide "stromaufwärts" angeordnet sind, spielt die Reihefolge keine Rolle.
Der Snapshot am Ende sollte identisch sein, egal, welche Reihenfolge sie wählt, nur der Verlauf wird ein wenig anders sein.
Sie entscheidet sich dafür, `issue54` zuerst einfließen zu lassen.

[source,console]
-----
$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)
-----

Es treten keine Probleme auf; wie Sie sehen können, war es ein einfacher "Fast-Forward".
Nun integriert Jessica die Arbeit von John (`origin/master`):

[source,console]
-----
$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

Alles lässt sich sauber zusammenführen und Jessicas Verlauf sieht jetzt so aus:

.Jessicas Verlauf nach dem Zusammenführen mit Johns Änderungen.
image::images/small-team-6.png[Jessica's history after merging John's changes.]

Jetzt ist `origin/master` von Jessicas `master`-Branch aus erreichbar, sodass sie in der Lage sein sollte, erfolgreich hochladen zu können (vorausgesetzt, John hat nicht inzwischen schon wieder etwas hochgeladen):

[source,console]
-----
$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -> master
-----

Jeder Entwickler hat einige Commits durchgeführt und jeweils die Arbeiten des anderen mit den eigenen zusammengeführt.

.Jessicas Verlauf nach dem Hochladen aller Änderungen auf den Server.
image::images/small-team-7.png[Jessica's history after pushing all changes back to the server.]

Das ist einer der einfachsten Arbeitsabläufe.
Sie arbeiten eine Weile, gewöhnlich an einem Themenbranch, und führen diesen mit ihrem master-Branch zusammen, wenn dieser soweit fertig ist, dass er integriert werden kann.
Wenn Sie diese Arbeit mit anderen teilen wollen, führen Sie die Änderungen mit ihrem eigenen `master`-Branch zusammen, holen eventuelle Änderungen vom Branch `origin/master` ab und führen diese mit ihren `master`-Branch zusammen, und schließlich laden sie alles auf den `master`-Branch auf den Server hoch.
Der generelle Ablauf sieht ungefähr so aus:

.Genereller Ablauf von Ereignissen für einen einfachen Arbeitsablauf mit mehreren Entwicklern.
image::images/small-team-flow.png[General sequence of events for a simple multiple-developer Git workflow.]

==== Geführte vertrauliche Teams

(((contributing, private managed team)))
In diesem Szenario werden Sie die Funktionen von Mitarbeitern in einem größeren, nicht öffentlich arbeitenden Team betrachten.
Sie werden erfahren, wie Sie in einem Umfeld arbeiten können, wo in kleinen Gruppen an der Entwicklung einzelner Features gearbeitet wird und dann diese team-basierten Beiträge durch einen anderen Beteiligten integriert werden.

Sagen wir, John und Jessica arbeiten gerade zusammen an einem Feature, während Jessica und Josie gerade an einem zweiten arbeiten.
Das Unternehmen benutzt in diesem Fall einen Typ des Arbeitsablaufs mit Integrationsmanager, bei dem die Arbeit der individuellen Gruppen nur durch bestimmte Mitarbeiter integriert wird und der `master`-Branch des Haupt-Repositorys auch nur durch eben diese Mitarbeiter aktualisiert werden kann.
Die ganze Arbeit wird in diesem Szenario auf team-basierten Branches ausgeführt und später von den Integrationsmanagern zusammengeführt.

Lassen Sie uns Jessicas Arbeitsablauf betrachten, wie sie in diesem Umfeld parallel mit zwei verschiedenen Entwicklern an ihren beiden Features arbeitet.
Vorausgesetzt, sie hat ihr Repository bereits geklont, entscheidet sie sich, zuerst an `featureA` zu arbeiten.
Sie erzeugt einen neuen Branch für das Feature und arbeitet etwas daran:

[source,console]
-----
# Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

An diesem Punkt muss sie den Stand ihrer Arbeiten John mitteilen, also lädt sie ihre Commits von `featureA`-Branch auf den Server hoch.
Jessica hat keine Schreibrechte auf dem `master`-Branch - den haben nur die Integrationsmanager - also muss sie auf einen anderen Branch hochladen, um mit John zusammenarbeiten zu können.

[source,console]
-----
$ git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -> featureA
-----

Jessica sendet John eine E-Mail, um ihm mitzuteilen, dass einige Änderungen auf einen neuen Branch namens `featureA` hochgeladen hat und er nun einen Blick darauf werfen kann.
Während sie auf ein Feedback von John wartet, entscheidet sich Jessica, mit der Arbeit an `featureB` zu beginnen - diesmal gemeinsam mit Josie.
Am Anfang legt sie einen neuen Feature-Branch an, basierend auf dem `master`-Branch, welcher sich auf dem Server befindet (`origin/master`):  

[source,console]
-----
# Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'
-----

Jetzt führt Jessica eine Reihe von Commits auf dem `featureB`-Branch durch:

[source,console]
-----
$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)
-----

Jessicas Repository sieht jetzt so aus:

.Jessicas ursprünglicher Commit-Verlauf.
image::images/managed-team-1.png[Jessica's initial commit history.]

Jessica könnte ihre Arbeit jetzt hochladen, aber sie bekommt eine E-Mail von Josie, in der diese mitteilt, dass bereits ein Branch namens `featureBee` hochgeladen wurde, welcher einige erste Änderungen beinhaltet.
Jessica muss also erst diese Änderungen mit ihren eigenen Änderungen zusammenführen, bevor sie selbst etwas hochladen kann.
Sie kann Josies Änderungen mit `git fetch` herunterladen:

[source,console]
-----
$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -> origin/featureBee
-----

Jessica kann jetzt dies mit den Änderungen, die sie vorgenommen hat, zusammenführen:

[source,console]
-----
$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)
-----

Dabei gibt es ein kleines Problem - sie muss die zusammengeführten Änderungen in ihrem `featureB`-Branch in den `featureBee`-Branch auf dem Server hochladen.
Sie kann dies erledigen, indem sie die Anweisung `git push` verwendet und dabei den lokalen Branch festlegt, gefolgt von einem Doppelpunkt (:), gefolgt vom Branch auf dem entfernten Server:

[source,console]
-----
$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -> featureBee
-----

Das bezeichnet man als _refspec_.
Siehe <<_refspec>> für detailliertere Diskussionen von Gits refspecs und verschiedenden Dingen, die Sie damit machen können.
Beachten Sie auch die Option `-u`; das ist die Kurzform von `--set-upstream`, welche die Branches für ein einfacheres Hoch- und Herunterladen konfiguriert.

Als Nächstes sendet John eine E-Mail an Jessica, um sie zu informieren, dass er einige Änderungen auf den `featureA`-Branch hochgeladen hat, und um sie zu bitten, diese zu überprüfen.
Sie führt die Anweisung `git fetch` aus, um diese Änderungen herunter zu laden:

[source,console]
-----
$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -> origin/featureA
-----

Um zu sehen, was geändert wurde, benutzt sie die Anweisung `git log`:

[source,console]
-----
$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25
-----

Schließlich lässt sie Johns Änderungen in ihren eigenen `featureA`-Branch einfließen: 

[source,console]
-----
$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)
-----

Jessica möchte etwas optimieren, also führt sie wieder einen Commit durch und lädt dann das Ganze auf den Server hoch:

[source,console]
-----
$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -> featureA
-----

Jessicas Commit-Verlauf sieht jetzt ungefähr so aus:

.Jessicas Verlauf nach dem Commit auf den Feature-Branch.
image::images/managed-team-2.png[Jessica's history after committing on a feature branch.]

Jessica, Josie und John informieren die Integrationsmanager, dass die Branches `featureA` und `featureBee` auf dem Server soweit fertiggestellt sind, um in die Hauptlinie integriert zu werden.
Nachdem die Integrationsmanager diese Branches mit der Hauptlinie zusammengeführt haben, wird beim Abholen der Daten vom Server der neue Merge-Commit heruntergeladen, was den Commit-Verlauf dann so aussehen lässt:

.Jessicas Verlauf nach dem Zusammenführen mit ihren beiden Themenbranches.
image::images/managed-team-3.png[Jessica's history after merging both her topic branches.]

Viele Teams wechseln zu Git, weil es damit möglich ist, dass mehrere Teams parallel arbeiten können und die verschiedenen Entwicklungslinien erst später im Prozess zusammengeführt werden.
Ein riesiger Vorteil von Git besteht darin, dass man in kleinen Untergruppen eines Teams über entfernte Branches zusammenarbeiten kann, ohne notwendigerweise das gesamte Team zu involvieren oder zu behindern.
Die Reihenfolge bei dem Arbeitsablauf, den Sie gesehen haben, ist ungefähr folgende:

.Grundlegende Reihenfolge des Arbeitsablaufs bei einem geführten Team.
image::images/managed-team-flow.png[Basic sequence of this managed-team workflow.]

[[_public_project]]
==== Verteiltes öffentliches Projekt

(((contributing, public small project)))
An einem öffentlichen Projekt mitzuarbeiten, ist ein wenig anders.
Da Sie keine Berechtigungen haben, die Branches des Projektes direkt zu aktualisieren, müssen Sie die Änderungen auf andere Art und Weise zu den Projektbetreibern bekommen.
Dieses erste Beispiel beschreibt die Mitarbeit mittels "Forking" auf Git-Hosting-Servern, welche einfaches "Forking" unterstützen.
Viele Hosting-Websites unterstützen dies (einschließlich GitHub, BitBucket, Google Code repo.or.cz und andere), und viele Projektbetreiber erwarten diese Art der Zuarbeit.
Der nächste Abschnitt handelt von Projekten, welche die Abgabe von Patches bevorzugt via E-Mail akzeptieren.

Zunächst werden Sie vermutlich das Hauptrepository klonen wollen, einen Themenbranch anlegen für den Patch oder die Serie von Patches, die Sie beisteuern möchten, und dann darin arbeiten.
Die Reihenfolge sieht dann in etwa so aus:

[source,console]
-----
$ git clone (url)
$ cd project
$ git checkout -b featureA
# (work)
$ git commit
# (work)
$ git commit
-----

[NOTE]
====
Es empfiehlt sich, die Anweisung `git rebase -i` zu verwenden, um die verschiedenen Commits zu einem einzigen zusammenzufassen oder um sie in anderer Weise neu zu arrangieren, sodass es für die Projektbetreiber leichter ist, die Änderungen zu überprüfen- – siehe <<_rewriting_history>> für weitere Informationen über interaktives Rebasing.
====

Wenn Sie mit der Arbeit an ihrem Branch fertig sind und Sie ihren Beitrag den Projektbetreibern zur Verfügung stellen wollen, gehen Sie auf die Projektseite und klicken auf den ``Fork''-Button, um Ihren eigenen Fork des Projektes anzulegen, in den Sie dann schreiben können.
Die URL des Repositorys dieses Forks müssen Sie dann als ein zweites, entferntes Repository (``remote'') einrichten, in diesem Beispiel hat es den Namen `myfork`:

[source,console]
-----
$ git remote add myfork (url)
-----

Dann müssen Sie Ihre Änderungen dorthin hochladen.
Am einfachsten ist es, den Themenbranch, an dem Sie gerade arbeiten, in Ihr Repository hochzuladen, anstatt ihn mit Ihrem `master`-Branch zusammenzuführen und diesen dann hochzuladen.
Der Grund dafür ist, dass Sie Ihren `master`-Branch nicht zurücksetzen müssen, falls Ihre Änderungen nicht akzeptiert werden.
Wenn die Projektbetreiber Ihre Änderungen übernehmen, ob mit `merge`, `rebase` oder `cherry-pick`, werden Sie diese schließlich sowieso zurückbekommen mittels `git pull` von deren Repository.

[source,console]
-----
$ git push -u myfork featureA
-----

(((git commands, request-pull)))
Wenn Sie Ihre Arbeit in Ihren Fork hochgeladen haben, müssen Sie den Projektbetreiber benachrichtigen.
Dies wird häufig als ``pull request'' bezeichnet und Sie können diesen entweder direkt über die Webseite erzeugen - GitHub hat seinen eigenen ``Pull Request''-Mechanismus, welchen wir in <<_github>> näher betrachten - oder Sie können die Anweisung `git request-pull` ausführen und die Ausgabe manuell per E-Mail an den Projektbetreiber schicken.

Die Anweisung `request-pull` nimmt den Ausgangsbranch, für den Ihre Änderungen bestimmt sind, und die URL des Git-Repositorys, von dem Ihre Änderungen heruntergeladen werden sollen, und gibt eine Zusammenfassung aller Änderungen aus, um deren Übernahme Sie bitten.
Wenn Jessica z. B. einen ``pull request'' an John schicken will, und sie zwei Commits auf dem gerade hochgeladenen Themenbranch durchgeführt hat, kann sie diese Anweisung ausführen:

[source,console]
-----
$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)
-----

Die Ausgabe kann an die Projektbetreiber geschickt werden – sie sagt ihnen, auf welcher Stelle der Branch angelegt wurde, fasst die Commits zusammen und gibt an, aus welchem Fork oder Repository man die Änderungen herunterladen kann.

Bei einem Projekt, wo Sie nicht selbst der Betreiber sind, ist es im Allgemeinen einfacher, einen Branch wie `master` zu haben, welcher immer den `origin/master`-Branch verfolgt, und Ihre eigenen Änderungen in Themenbranches vorzunehmen, die Sie leicht verwerfen können, wenn diese nicht akzeptiert werden.
Wenn Sie Schwerpunkte Ihrer Arbeit in Themenbranches unterteilen, können Sie diese außerdem recht leicht auf den letzten Stand des Hauptrepositorys rebasen, falls das Hauptrepository in der Zwischenzeit weiter entwickelt wurde und Ihre Commits sich nicht mehr sauber anwenden lassen.
Wollen Sie beispielsweise Änderungen zu einem weiteren Thema für das Projekt beisteuern, dann arbeiten Sie nicht weiter auf dem Themenbranch, den Sie gerade hochgeladen haben - sondern beginnen Sie von vorn vom `master`-Branch des Hauptrepositorys:

[source,console]
-----
$ git checkout -b featureB origin/master
# (work)
$ git commit
$ git push myfork featureB
# (email maintainer)
$ git fetch origin
-----

Jedes Ihrer Themen befindet sich jetzt in einer Art Silo - ähnlich zu einer Patch Queue – sodass Sie diese neu schreiben, rebasen und ändern können, ohne dass die Themen sich gegemseitig stören oder voneinander abhängen:

.Ursprünglicher Commit-Verlauf bei der Arbeit an `featureB`.
image::images/public-small-1.png[Initial commit history with `featureB` work.]

Sagen wir, der Projektbetreiber hat eine Menge von anderen Patches übernommen und versucht, Ihren ersten Branch einfließen zu lassen, aber dieser lässt sich nicht mehr sauber anwenden.
In diesem Fall können Sie Ihre Änderungen auf dem letzten Stand des `origin/master`-Branches mittels Rebase hinzufügen, die Konflikte für den Projektbetreiber beheben und Ihre Arbeit erneut einreichen:

[source,console]
-----
$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA
-----

Das schreibt Ihren Commit-Verlauf neu, sodass dieser jetzt so aussieht <<psp_b>>.

[[psp_b]]
.Commit-Verlauf nach dem Rebase von `featureA`.
image::images/public-small-2.png[Commit history after `featureA` work.]

Da Sie den Branch mittels Rebase hinzugefügt haben, müssen Sie die Anweisung `git push` mit der Option `-f` verwenden, um den `featureA`-Branch auf dem Server mit einem Commit ersetzen zu können, der nicht vom gegenwärtig letzten Commit des entfernten Branches abstammt.
Eine Alternative dazu wäre, diese neuen Änderungen in einen anderen Branch auf dem Server hochzuladen (vielleicht namens `featureAv2`).

Schauen wir uns noch ein weiteres mögliches Szenario an: der Projektbetreiber hat sich Ihre Arbeit in Ihrem zweiten Branch angesehen und mag das Konzept, aber er bittet Sie, noch ein Detail an der Implementierung zu ändern.
Sie werden die Gelegenheit außerdem nutzen, um Ihre Änderungen zu verschieben, damit diese auf dem aktuellen `master`-Branch des Projektes basieren. 
Sie legen dazu ausgehend vom aktuellen `origin/master`-Branch einen neuen Branch an, führen Ihre Änderungen aus `featureB` damit zusammen, lösen dabei jegliche Konflikte, erledigen die gewünschte Änderung an der Implementierung und laden das Ganze als neuen Branch hoch:

(((git commands, merge, squash)))
[source,console]
-----
$ git checkout -b featureBv2 origin/master
$ git merge --no-commit --squash featureB
# (change implementation)
$ git commit
$ git push myfork featureBv2
-----

Die Option `--squash` fasst alle Änderungen des einfließenden Branches (featureB) zusammen und quetscht diese in einen Nicht-Merge-Commit an der Spitze des Branches, auf dem Sie sich gerade befinden.
Die Option `--no-commit` weist Git außerdem an, nicht automatisch einen Commit anzulegen.
Das ermöglicht Ihnen, sämtliche Änderungen aus einem anderen Branch zu übernehmen und dann weitere Änderungen vorzunehmen, bevor Sie einen neuen Commit aufzeichnen.

Jetzt können Sie dem Projektbetreiber eine Nachricht schicken, dass Sie die gewünschten Änderungen vorgenommen haben und dass er Ihre Änderungen in Ihrem `featureBv2`-Branch finden kann.

.Commit-Verlauf nach den Änderungen an `featureBv2`.
image::images/public-small-3.png[Commit history after `featureBv2` work.]

[[_project_over_email]]
==== Öffentliches Projekt via E-Mail

(((contributing, public large project)))
Viele Projekte haben festgelegte Verfahren, um Patches entgegenzunehmen - Sie werden sich mit den jeweiligen Regeln vertraut machen müssen, da diese bei jedem Projekt unterschiedlich sein werden.
Da ist etliche ältere, große Projekte gibt, welche Patches über eine Mailingliste der Entwickler entgegennehmen, werden wir auf dieses Beispiel als Nächstes eingehen.

Der Arbeitsablauf ist ähnlich dem im vorherigen Anwendungsfall - Sie erzeugen Themenbranches für jede Patchserie, an der Sie arbeiten.
Der Unterschied besteht dann darin, wie Sie die Änderungen an das Projekt übermitteln.
Anstatt das Projekt zu forken und Änderungen in Ihren Fork hochzuladen, erzeugen Sie E-Mail-Versionen von jeder Ihrer Commit-Folgen und senden diese an die Mailingliste der Entwickler.

[source,console]
-----
$ git checkout -b topicA
# (work)
$ git commit
# (work)
$ git commit
-----

(((git commands, format-patch)))
Jetzt haben Sie zwei Commits, die Sie an die Mailingliste schicken wollen.
Sie verwenden die Anweisung `git format-patch`, um die Dateien im mbox-Format zu erzeugen, die Sie per E-Mail an die Mailingliste schicken können - diese Anweisung macht aus jedem Commit eine E-Mail-Nachricht, wobei die erste Zeile der Commit-Nachricht zum Betreff der E-Mail wird und der Rest der Commit-Nachricht sowie der Patch des Commits selbst wird zum Text der E-Mail.
Das Schöne daran ist, dass bei der Anwendung eines Patches von einer mit `format-patch` erzeugten E-Mail alle Commit-Informationen ordnungsgemäß erhalten bleiben.

[source,console]
-----
$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
-----

Die Anweisung `git format-patch` zeigt Ihnen die Namen der Patch-Dateien an, die er erzeugt hat.
Die Option `-M` weist Git an, nach umbenannten Dateien Ausschau zu halten.
Die Dateien sehen dann so aus:

[source,console]
-----
$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0
-----

Sie können diese Patch-Dateien auch bearbeiten, um weitere Informationen für die Mailingliste hinzuzufügen, die nicht in der Commit-Nachricht erscheinen sollen.
Wenn Sie Text zwischen der `---` Zeile und dem Anfang des Patches (der Zeile `diff --git`) hinzufügen, dann können die Entwickler diesen lesen, bei der Anwendung des Patches wird er aber ausgeschlossen.

Um das jetzt an eine Mailingliste zu schicken, können Sie die Datei entweder in Ihrem E-Mail Programm einfügen oder sie über ein Befehlszeilen-Programm direkt verschicken.
Das Einfügen des Textes verursacht oft Formatierungsprobleme – insbesondere mit ``smarten'' E-Mail-Clients, welche Zeilenumbrüche und Leerzeichen nicht adäquat erhalten.
Zum Glück bringt Git aber ein Tool mit, was Ihnen dabei behilflich ist, ordnungsgemäß formatierte Patches über IMAP zu verschicken, was einfacher für Sie sein könnte.
Wir werden demonstrieren, wie man Patches über Gmail verschickt, welches der E-Mail-Client ist, mit dem wir uns am besten auskennen; Sie können detaillierte Anleitungen für eine Reihe von E-Mail-Programme am Ende der schon erwähnten Datei `Documentation/SubmittingPatches` im Git Quellcode nachlesen.

(((git commands, config)))(((email)))
Zunächst müssen Sie den Abschnitt IMAP in Ihrer `~/.gitconfig`-Datei einrichten.
Sie können jeden Wert separat mit einer Reihe von `git config`-Anweisungen eingeben oder die Datei öffnen und die Werte manuell eingeben, am Ende sollte Ihre config-Datei in etwa so aussehen:

[source,ini]
-----
[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false
-----

Wenn Ihr IMAP-Server kein SSL verwendet, sind die letzten beiden Zeilen wahrscheinlich nicht nötig und der Host-Wert müsste `imap://` statt `imaps://` lauten.
Wenn Sie diese Einstellungen vorgenommen haben, können Sie `git send-email` verwenden, um die Patches im Entwurfsordner des angegebenen IMAP-Servers zu platzieren:

[source,console]
-----
$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
Emails will be sent from: Jessica Smith <jessica@example.com>
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
-----

Git gibt dann für jeden Patch, den Sie versenden, ein paar Log-Informationen aus, die in etwa so aussehen:

[source,text]
-----
(mbox) Adding cc: Jessica Smith <jessica@example.com> from
  \line 'From: Jessica Smith <jessica@example.com>'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith <jessica@example.com>
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: <y>
References: <y>

Result: OK
-----

Jetzt sollten Sie in der Lage sein, zum Entwurfsordner Ihres E-Mail-Clients zu gehen, als Empfänger die Adresse der Mailingliste anzugeben, an die Sie den Patch senden wollen, möglicherweise den Projektbetreiber oder einen anderen Verantwortlichen auf CC zu setzen und die E-Mail dann zu verschicken.

==== Zusammenfassung

Dieser Abschnitt hat eine Reihe von gebräuchlichen Arbeitsabläufen behandelt, die für jeweils sehr verschiedene Arten von Projekten üblich sind und denen Du vermutlich begegnen wirst. Wir haben außerdem ein paar neue Tools vorgestellt, die dabei hilfreich sind, diese Workflows umzusetzen.
Als nächstes werden wir auf die andere Seite dieser Medaille eingehen: wie Sie selbst ein Git Projekt betreiben können.
Sie werden erfahren, wie Sie als „wohlwollender Diktator“ oder als Integrationsmanager arbeiten können.