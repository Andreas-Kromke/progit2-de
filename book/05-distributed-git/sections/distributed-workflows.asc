=== Verteilter Arbeitsablauf

(((workflows)))
Im Gegensatz zu CVCSs (Centralized Version Control Systems) können Sie dank der verteilten Struktur von Git die Zusammenarbeit von Entwicklern in Projekten wesentlich flexibler gestalten.
In zentralisierten Systemen fungieren alle Entwickler als gleichwertige Netzknoten, die mehr oder weniger in der gleichen Art und Weise an einem zentralen Hub arbeiten.
In Git dagegen ist jeder Entwickler potentiell beides – Netzknoten und zentraler Hub, d.h. jeder Entwickler kann sowohl Code zu anderen Repositories beitragen als auch selbst ein öffentliches Repository unterhalten, auf welchem wiederum andere Ihre Arbeit aufbauen und an dem sie mitarbeiten können.
Das eröffnet eine Fülle von möglichen Arbeitsabläufen (engl. Workflows) für Ihr Projekt, weshalb wir einige gängige Verfahren behandeln werden, die diese Flexibilität nutzen.
Wir werden auf die Stärken und möglichen Schwächen der einzelnen Entwürfe eingehen; Sie können einen einzelnen davon auswählen, um ihn zu nutzen, oder Sie können die Funktionalitäten von allen miteinander kombinieren.

==== Zentralisierter Arbeitsablauf

(((workflows, centralized)))
In einem zentralisierten System gibt es im Allgemeinen ein einziges Modell für die Zusammenarbeit – der zentralisierte Workflow.
Ein zentraler Hub (oder _Repository_) kann Code von anderen akzeptieren und übernehmen, und alle Beteiligten synchronisieren ihre Arbeit damit.
Eine Reihe von Entwicklern sind Netzknoten – Abnehmer von diesem Hub – und synchronisieren ihre Arbeit mit diesem einen, zentralen Punkt.

.Zentralisierter Workflow.
image::images/centralized_workflow.png[Zentralisierter Arbeitsablauf.]

Das bedeutet, wenn zwei Entwickler ein Repository vom zentralen Knotenpunkt klonen und beide lokal Änderungen vornehmen, dann kann der Entwickler, welcher als erster seine Änderungen ins zentrale Repository hochladen möchte, dies ohne Probleme tun.
Der zweite Entwickler muss jedoch zunächst die Änderungen des ersten Entwicklers bei sich einfließen lassen, bevor er seine eigenen Änderungen hochladen kann, damit er die Änderungen des ersten Entwicklers nicht überschreibt.
Dieses Prinzip gilt sowohl für Git als auch für Subversion(((Subversion))) (oder irgendein anderes CVCS). Das Konzept funktioniert bei Git perfekt.

Wenn Sie in Ihrer Firma oder in Ihrem Team bereits mit einem zentralisierten Arbeitsablauf vertraut sind, können Sie einfach so weitermachen und diesen Arbeitsablauf mit Git realisieren.
Richten Sie einfach ein einziges Repository ein und geben Sie jedem in Ihrem Team Schreibzugriff („push access“). Git sorgt dann dafür, dass niemand die Arbeit von anderen überschreiben kann.

Angenommen, John und Jessica beginnen gleichzeitig mit der Arbeit.
John beendet seine Änderungen und lädt diese auf den Server hoch.
Dann versucht Jessica, ihre Änderungen hochzuladen, aber der Server weist diese zurück.
Ihr wird mitgeteilt, dass sie versucht hat „non-fast-forward“ Änderungen hochzuladen und dass sie das erst dann durchführen kann, wenn sie zuvor vorhandene andere Änderungen geholt und zusammengeführt hat.
Viele Anwender mögen diesen Arbeitsablauf, weil sie mit dem bewährten Modell bereits vertraut sind und es bequem ist.

Das gilt nicht nur für kleine Teams.
Mit dem Branching-Modell von Git ist es Hunderten von Entwicklern möglich, an einem einzelnen Projekt, über Dutzende von Branches, gleichzeitig erfolgreich zu arbeiten.

[[_integration_manager]]
==== Arbeitsablauf mit Integrationsmanager

(((workflows, integration manager)))
Da Git es Ihnen ermöglicht, mehrere Remote-Repositorys zu betreiben, ist ein Workflow möglich, bei dem jeder Entwickler Schreibzugriff auf sein eigenes öffentliches Repository und Lesezugriff auf alle anderen hat.
Dieses Szenario beinhaltet häufig ein eigens dafür eingerichtetes Repository, welches das „offizielle“ Projekt darstellt.
Um Änderungen zu einem solchen Projekt beizusteuern, können Sie Ihren eigenen öffentlichen Klon des Projektes anlegen und Ihre Änderungen dorthin hochladen.
Anschließend können Sie den Betreiber des Haupt-Repositories bitten, Ihre Änderungen in sein Repository zu übernehmen.
Der Betreiber kann dann Ihr Repository als ein entferntes Repository auf seinem Rechner hinzufügen, Ihre Änderungen lokal testen, diese in einen seiner Branches einfließen lassen und dann in sein öffentliches Repository hochladen.
Dieser Prozess läuft wie folgt ab (siehe <<wfdiag_b>>):

1.  Der Projektbetreiber lädt in sein öffentliches Repository hoch.
2.  Ein Mitwirkender klont dieses Repository und nimmt Änderungen vor.
3.  Der Beitragende lädt diese in sein eigenes öffentliches Repository hoch.
4.  Der Beitragende schickt dem Betreiber eine E-Mail und bittet darum, die Änderungen zu übernehmen.
5.  Der Betreuer fügt das Repository des Beitragenden als ein Remote-Repository hinzu und führt die Änderungen lokal zusammen.
6.  Der Betreuer lädt die zusammengeführten Änderungen in das Haupt-Repository hoch.

[[wfdiag_b]]
.Arbeitsablauf mit Integrationsmanager.
image::images/integration-manager.png[Arbeitsablauf mit Integrationsmanager.]

(((forking)))
Das ist ein sehr verbreiteter Workflow bei hub-basierten Werkzeugen wie GitHub oder GitLab, wo es sehr einfach ist, ein Projekt zu „forken“ und Ihre Änderungen in Ihren eigenen Fork hochzuladen, wo jeder sie sehen kann.
Einer der Hauptvorteile dieser Vorgehensweise ist, dass Sie an Ihrem Fork weiterarbeiten können und der Betreiber des Haupt-Repositorys Ihre Änderungen jederzeit übernehmen kann.
Mitarbieter müssen nicht darauf warten, dass der Betreiber ihre Änderungen einarbeitet – jeder Beteiligte kann in seinem eigenen Tempo arbeiten.

==== Arbeitsablauf mit Diktator und Leutnants

(((workflows, dictator and lieutenants)))
Dies ist eine Variante eines Arbeitsablaufs mit vielen Repositories.
Sie wird normalerweise bei sehr großen Projekten mit hunderten von Mitarbeitern verwendet; ein bekanntes Beispiel ist der Linux Kernel.
Verschiedene Integrationsmanager sind zuständig für bestimmte Teile des Repositorys; sie werden _Leutnants_ genannt.
Alle Leutnants haben wiederum einen Integrationsmanager, der als der wohlwollende Diktator (benevolent dictator) bezeichnet wird.
Der wohlwollende Diktator pusht von seinem Verzeichnis zu einem Referenz-Repository, aus dem alle Beteiligten ihre eigenen Repositories aktualisieren müssen.
Dieser Prozess funktioniert wie folgt (siehe <<wfdiag_c>>):

1.  Normale Entwickler arbeiten an ihren Themenbranches und fügen Ihre Arbeit an der Spitze des `master` Branch mittels Rebase ein.
    Der `master` Branch ist der des Referenz-Repositorys, in das der Diktator pusht.
2.  Die Leutnants führen die Themenbranches der Entwickler mit ihren `master` Branches zusammen.
3.  Der Diktator führt die `master`-Branches der Leutnants mit seinem eigenen `master`-Branch zusammen.
4.  Der Diktator lädt seinen `master`-Branch ins Referenz-Repository hoch, damit die anderen Entwickler darauf einen Rebase durchführen können.

[[wfdiag_c]]
.Arbeitsablauf mit wohlwollendem Diktator.
image::images/benevolent-dictator.png[Arbeitsablauf mit wohlwollendem Diktator.]

Diese Art Arbeitsablauf ist nicht weit verbreitet, kann aber bei sehr großen Projekten oder in stark hierarchischen Umgebungen sehr nützlich sein.
Er ermöglicht es dem Projektleiter (dem Diktator), Arbeit in großem Umfang zu delegieren und große Teilbereiche von Code an verschiedenen Punkten einzusammeln, bevor diese integriert werden.

==== Zusammenfassung Arbeitsabläufe

Dies sind einige häufig verwendete Arbeitsabläufe, die mit verteilten Systemen wie Git möglich sind, aber Sie können sehen, dass viele Variationen möglich sind, um genau zu Ihrem speziellen Arbeitsablauf in der realen Welt zu passen.
Jetzt, da Sie (hoffentlich) bestimmen können, welche Kombination von Arbeitsabläufen bei Ihnen funktionieren würde, werden wir einige spezifischere Beispiele davon betrachten, wie man die Hauptaufgaben durchführen kann, welche die unterschliedliche Abläufe ausmachen.
Im nächsten Abschnitt erfahren Sie etwas über gängige Formen der Mitarbeit an einem Projekt.
